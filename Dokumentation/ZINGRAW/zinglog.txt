ðŸ˜Ž Ja. Und zwar eindeutig.
Dein Log ist pures Gold â€“ da reagiert mehr als genug, und man sieht sehr klar, wo der Hebel sitzt. Lass mich das prÃ¤zise auseinanderziehen und dann direkt sagen, was die Schuss-Maschine als NÃ¤chstes tun soll.


---

ðŸ”¥ Was wir JETZT sicher wissen (aus deinem Log)

1ï¸âƒ£ Inkbird = READ-Pull + WRITE-Trigger (kein Notify)

Du hast es selbst gesehen â€“ und das Log bestÃ¤tigt es:

fff7 reagiert NUR nach WRITE

Danach liefern READs stabile, strukturierte Payloads

Vor WRITE: quasi statisch

Nach WRITE (0D, spÃ¤ter FF): Daten Ã¤ndern sich


ðŸ‘‰ klassischer Command-gated READ Channel


---

2ï¸âƒ£ 0000fff7 ist der History-Datenkanal

Das ist jetzt ziemlich sicher:

Beispiel Payload:

01-7E-80-00-4F-4C-02-00-95-7B-FF-1F-E1-8B-00-00-30-7B-FF-1F

Merkmale:

konstante LÃ¤nge

mehrere Offsets Ã¤ndern sich

Wiederholbares Muster

Reagiert direkt auf:

WRITE 0D

WRITE FF



ðŸ‘‰ Das ist kein Status, das sind Records.


---

3ï¸âƒ£ Descriptor 0x2901 ist nur Label / Mode-Info

Alles mit:

"history data"

"his data type"

"cfg data"

"measure"

"reset"


ist nur Beschreibung, kein Schalter.

Dass WRITE dort NOT PERMIT ist, ist korrekt und irrelevant.

ðŸ‘‰ Ignorieren. Nicht anfassen.


---

4ï¸âƒ£ fff1 / fff2 / fff3 = Meta / Status / Pointer

Kurzklassifikation aus deinem Verhalten:

UUID	Verhalten	Bedeutung

fff1	READ konstant	Config / Header
fff2	READ kurz	Status / Cursor
fff3	READ nulls	Mode abhÃ¤ngig
fff7	READ variabel nach WRITE	HISTORY DATA


ðŸ‘‰ fff7 ist unser Fokus.


---

ðŸ§  Mentales Modell (jetzt glasklar)

Inkbird hat intern sehr wahrscheinlich:

[ History Memory ]
   â”œâ”€ Block A (Ã¤lter)
   â”œâ”€ Block B (neuer)
   â””â”€ Cursor / Mode Register

WRITE 0D â†’ prepare / select

WRITE FF â†’ switch / next / confirm

READ fff7 â†’ current page


Die 50-%-Pause aus der App passt perfekt zu:

> Block A komplett â†’ Umschalten â†’ Block B




---

ðŸŽ¯ NÃ„CHSTER KONKRETER STEP (ohne Rumraten)

ðŸ‘‰ Desktop-Gatt-Bridge: Script 1 â€“ Minimal Sweep

Ziel: sehen, ob fff7 bei wiederholtem READ paged oder streamt

{
  "mode": "script",
  "steps": [
    { "op": "write", "uuid": "0000fff7-0000-1000-8000-00805f9b34fb", "hex": "0D" },
    { "op": "wait", "ms": 120 },

    { "op": "read", "uuid": "0000fff7-0000-1000-8000-00805f9b34fb", "tag": "page", "repeat": 40, "delay_ms": 40 },

    { "op": "write", "uuid": "0000fff7-0000-1000-8000-00805f9b34fb", "hex": "FF" },
    { "op": "wait", "ms": 120 },

    { "op": "read", "uuid": "0000fff7-0000-1000-8000-00805f9b34fb", "tag": "page2", "repeat": 40, "delay_ms": 40 }
  ]
}

Was wir prÃ¼fen:

Ã¤ndern sich die Payloads pro READ?

wiederholen sie sich zyklisch?

gibt es einen harten Ãœbergang zwischen page und page2?


ðŸ‘‰ Wenn ja â†’ wir haben Paging.


---

ðŸ§© Danach (aber wirklich erst danach)

Erst nachdem wir rohe Zing-Logs haben:

Record-Size bestimmen

Timestamp-Felder finden

Temperatur/Humidity-Offsets erkennen

Decoder bauen (separat, offline)



---

ðŸ§  Fazit (und ja: du hast es gerochen)

> â€žUfff schau mal es reagiert sogarâ€œ



Nicht â€žsogarâ€œ.
Genau so muss es reagieren.

Du hast:

den richtigen Kanal

den richtigen Trigger

das richtige Tool (Schuss-Maschine)

den richtigen Flow (offline, read-only, reproduzierbar)


ðŸ”¥ Das Ding ist offen.
Jetzt nur noch systematisch auslesen â€“ ohne Stress, ohne UI-Gefrickel.

Wenn du willst, schauen wir als NÃ¤chstes nur EIN Zing-Log gemeinsam an und markieren die Bytes.
