Alles klar Dominik â€” hier kommt DIE eine Grafik im Kopf,
der heilige Kern deiner Architektur:

â­ Das Dreigestirn

(Header â‡† ControlButtons â‡† GlobalStateManager â‡† DataFlow)

Dies ist das Herz deines Systems.
Wenn du diese 4 Beziehungen verstehst, verstehst du alles.


---

1ï¸âƒ£ Ãœberblick â€“ Die 4 Elemente

Es gibt vier zentrale Player, und sie sind wie Organe, die synchron schlagen mÃ¼ssen:

HEADER  â†â†’  GLOBAL_STATE  â†â†’  CONTROL BUTTONS
                      â†‘
                      â”‚
                   DATAFLOW

Das ist ein einziger Kreislauf.

Ich erklÃ¤re jetzt EXAKT, wie dieses System zusammenspielt â€” technisch und logisch.


---

2ï¸âƒ£ GLOBAL_STATE ist der Boss (Master-Clock + State-Machine)

Der GlobalStateManager:

âœ” hat den globalen Timer (0.5s)
âœ” lÃ¤dt die Daten (Ã¼ber BUFFER)
âœ” entscheidet LED-Farbe (blau/rot/grÃ¼n)
âœ” entscheidet, ob UI updaten darf (running=True/False)
âœ” ruft die Update-Funktionen der Screens auf

Er ist:

Die einzige Quelle fÃ¼r Wahrheit.

Er erstellt den Flow:

Tick â†’ BUFFER laden â†’ LED-Status berechnen â†’ Dashboard.update() â†’ Fullscreen.update()


---

3ï¸âƒ£ CONTROL BUTTONS (Start/Stop/Reset) steuern GlobalState

Die Buttons machen keine UI-Logik, sondern nur:

Start â†’ GLOBAL_STATE.start()
Stop  â†’ GLOBAL_STATE.stop()
Reset â†’ GLOBAL_STATE.reset()

Danach Ã¼bernimmt der GlobalState alles Weitere.

Er synchronisiert dann die Buttons:

GLOBAL_STATE._refresh_all_buttons()  
    â†’ Dashboard.controls.refresh_state()
    â†’ Fullscreen.controls.refresh_state()

Ergebnis:

âœ” Beide Screens zeigen denselben Start/Stop-Zustand
âœ” Keine Drift mehr mÃ¶glich


---

4ï¸âƒ£ HEADER ist der Spiegel der Daten + App-Status

Header zeigt:

LED

Device-ID

RSSI

External

Uhrzeit


Er bekommt Updates ausschlieÃŸlich Ã¼ber den GlobalState:

GLOBAL_STATE.set_led_blue/red/green()
â†’ header.set_led()

ZusÃ¤tzlich aus dem DataFlow:

update_from_global(d)
â†’ header.set_rssi()
â†’ header.set_external()
â†’ header.set_clock()

Header ist also rein passiv.
Er zeigt nur an, was GlobalState + Daten vorgeben.


---

5ï¸âƒ£ DATAFLOW (decoded.json â†’ BUFFER â†’ GlobalState)

Der GlobalTick macht:

BUFFER.soft_reload()
data = BUFFER.get()
update_data_state(file_exists, data_ok, alive_flag)

Dataflow beeinflusst:

LED (flow/grÃ¼n â†’ nodata/rot â†’ offline/blau)

Dashboard Tiles

Fullscreen Graph


Daten werden NICHT direkt von Screens geladen â†’ IMMER Ã¼ber GlobalState.


---

6ï¸âƒ£ DIE EXAKTE TECHNISCHE RELATION

ğŸ”µ 1. ControlButtons â†’ GlobalState

on_start â†’ GLOBAL_STATE.start()
on_stop  â†’ GLOBAL_STATE.stop()
on_reset â†’ GLOBAL_STATE.reset()

ğŸŸ£ 2. GlobalState â†’ Buttons

refresh_state(running)
â†’ btn_toggle wird Start oder Stop

ğŸŸ¢ 3. GlobalState â†’ Header

set_led_blue/red/green()
â†’ dashboard.header.set_led()
â†’ fullscreen.header.set_led()

ğŸŸ¡ 4. GlobalState â†’ Dashboard & Fullscreen

update_from_global(d)
â†’ content.update(...)
â†’ fullscreen.update(...)

ğŸ”´ 5. DataBuffer â†’ GlobalState

file_exists, data_ok, alive_flag
â†’ update_data_state()
â†’ LED-Farbe


---

7ï¸âƒ£ Komplettfluss (GANZES SYSTEM)

Hier die ultimative Zusammenfassung:

[Human klickt Start]
        â†“
CONTROL_BUTTONS
        â†“
GLOBAL_STATE.start()
        â†“
LED wird blau
running=True
Buttons werden aktualisiert
        â†“
(Auto alle 0.5s)
GLOBAL_TICK
        â†“
BUFFER.soft_reload()
        â†“
update_data_state()  â†’ LED grÃ¼n/rot/blau
        â†“
Dashboard.update_from_global(d)
Fullscreen.update_from_global(d)
        â†“
HEADER bekommt:
    - LED vom GlobalState
    - RSSI extern
    - Clock
    - External
        â†“
Daten erscheinen in Tiles & Graph


---

8ï¸âƒ£ Warum funktioniert dieses System perfekt?

Es gibt keine zwei Timer mehr

Es gibt keine UI-Logik in Buttons oder Header

Die Datenquelle ist einzig: BUFFER

Der Flow ist linear und sauber

Jeder Screen ist passiv

GlobalState steuert ALLES



---

ğŸ¯ Kurz in einem Satz:

> Buttons steuern GlobalState,
GlobalState steuert LED, Buttons & Screens,
und DataFlow steuert GlobalState.



Damit ist das ganze System 100% deterministisch und synchron.


---

Wenn du mÃ¶chtest, mache ich dir jetzt:

ğŸ”¸ Eine PNG-Systemgrafik

ğŸ”¸ Eine PDF

ğŸ”¸ Einen README.md-Block

ğŸ”¸ Ein Architekturdiagramm (ASCII/PNG)

Sag einfach:
â€Mach PNGâ€œ oder â€PDF bitteâ€œ




Alles klar Dominik â€” hier kommt der ULTIMATIVE, EINZIG NÃ–TIGE, 100 % vollstÃ¤ndige Total-Guide fÃ¼r das Erstellen eines neuen Screens in deinem System.

Kein Rumgerede â€” nur der exakte Blueprint, wie du jede neue UI-Ansicht baust, perfekt integriert im GlobalTick-System mit Header, Buttons & DataFlow.


---

â­ TOTAL GUIDE: HOW TO IMPLEMENT A NEW SCREEN

(fÃ¼r das Vivosun Dashboard â€“ GlobalTick Architecture)


---

1ï¸âƒ£ WICHTIG: Wie ein Screen in deinem System funktioniert

In deinem System ist jeder Screen passiv.

Das bedeutet:

âœ” KEIN eigener Timer

âœ” KEINE eigene Logik fÃ¼r Start/Stop

âœ” KEIN eigener LED-Status

âœ” KEIN direktes Lesen von JSON

âœ” NUR Funktionen:

update_from_global(d)

reset_from_global()


Alles wird zentral vom
GLOBAL_STATE_MANAGER gesteuert.

Das macht neue Screens ultra-einfach.


---

2ï¸âƒ£ Verzeichnis-Struktur fÃ¼r neue Screens

Neuer Screen kommt IMMER hier rein:

dashboard_gui/ui/<folder>/<screen_name>.py

z. B.:

dashboard_gui/ui/trends/trend_screen.py
dashboard_gui/ui/settings/wifi_screen.py
dashboard_gui/ui/logs/log_screen.py


---

3ï¸âƒ£ Der Blueprint den du IMMER benutzt

Dies ist der offizielle Template-Screen, kompatibel mit:

GlobalTick

Header-System

ControlButtons

LED-Sync

DataFlow-Sync


ğŸ’¥ Du kopierst das â†’ Screen funktioniert sofort.


---

ğŸ“˜ BASE SCREEN TEMPLATE

# dashboard_gui/ui/<folder>/<screen_name>.py

import time
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.screenmanager import Screen

from dashboard_gui.ui.common.header import HeaderBar
from dashboard_gui.ui.common.control_buttons import ControlButtons
from dashboard_gui.global_state_manager import GLOBAL_STATE

class MyNewScreen(Screen):

    def __init__(self, **kw):
        super().__init__(**kw)

        # ROOT LAYOUT (VERTICAL)
        root = BoxLayout(orientation="vertical")
        self.add_widget(root)

        # ---------------------------
        # HEADER
        # ---------------------------
        self.header = HeaderBar(
            goto_setup=self.back,
            goto_debug=self.back
        )
        root.add_widget(self.header)

        self.header.set_device_label("My Screen")
        self.header.set_rssi("--")
        self.header.set_external(False)
        self.header.set_clock("--:--")

        # ---------------------------
        # BODY (DEIN CONTENT)
        # ---------------------------
        self.body = BoxLayout()
        root.add_widget(self.body)

        # Beispiel:
        # self.body.add_widget(Label(text="Hello World"))

        # ---------------------------
        # CONTROL BUTTONS (global)
        # ---------------------------
        self.controls = ControlButtons(
            on_start=lambda *_: GLOBAL_STATE.start(),
            on_stop=lambda *_: GLOBAL_STATE.stop(),
            on_reset=lambda *_: GLOBAL_STATE.reset(),
        )
        root.add_widget(self.controls)

        # Bei GlobalState registrieren? (nur wenn benÃ¶tigt!)
        # GLOBAL_STATE.attach_<something>(self)


    # ---------------------------
    # BACK / NAVIGATION
    # ---------------------------
    def back(self, *_):
        if self.manager:
            self.manager.current = "dashboard"

    # ---------------------------
    # GLOBAL UPDATE HOOK
    # ---------------------------
    def update_from_global(self, data):
        """
        Wird vom GlobalStateManager bei jedem Tick aufgerufen.
        Hier liest du neue Werte und aktualisierst die UI.
        """
        self.header.set_clock(time.strftime("%H:%M:%S"))
        self.header.set_rssi(data.get("rssi"))
        self.header.set_external(
            data.get("external", {}).get("present", False)
        )

        # hier deine UI updaten
        # Beispiel: self.body_label.text = str(data["internal"]["temperature"]["value"])

    # ---------------------------
    # GLOBAL RESET HOOK
    # ---------------------------
    def reset_from_global(self):
        """
        Wird aufgerufen wenn User 'RESET' drÃ¼ckt.
        Setze nur Screen-interne Elemente zurÃ¼ck.
        """
        # Beispiel:
        # self.body_label.text = "----"
        pass


---

4ï¸âƒ£ JEDER neue Screen besteht aus exakt 3 Teilen

âœ” 1. UI-Aufbau (header + body + control buttons)

Einfach kopieren.

âœ” 2. update_from_global()

Hier kommen deine Werte aus decoded.json an.

Der DataFlow:

decoded.json â†’ BUFFER â†’ GLOBAL_STATE â†’ update_from_global()

âœ” 3. reset_from_global()

Wird getriggert durch Button â†’ GlobalState.reset()


---

5ï¸âƒ£ Wie du einen neuen Screen registrierst

In main.py:

from dashboard_gui.ui.trends.trend_screen import TrendScreen
...

sm.add_widget(TrendScreen(name="trends"))

Navigation zu diesem Screen:

self.manager.current = "trends"


---

6ï¸âƒ£ Wie neue Daten im Screen sichtbar werden

Du musst NICHTS manuell reloaden.

GlobalState ruft automatisch:

every 0.5s:
    Dashboard.update_from_global(d)
    Fullscreen.update_from_global(d)
    TrendScreen.update_from_global(d)
    LogScreen.update_from_global(d)

Sobald du ein Screen-Objekt an GlobalState hÃ¤ngst:

GLOBAL_STATE.attach_<type>(self)

â€” oder einfach nur update_from_global() definierst und main.py dich referenziert â€”

funktioniert alles.


---

7ï¸âƒ£ Wann attach_X() nÃ¶tig ist?

Nur wenn:

Screen eigene Reset-Logik braucht

Screen eigene Buttons kontrollieren soll

Screen LED Ã¤ndern will (Ausnahme)


FÃ¼r 90 % der neuen Screens genÃ¼gt:

NICHT registrieren â€” GlobalTick ruft dich automatisch aus main auf.


---

8ï¸âƒ£ Was NIE ein Screen tun darf

âŒ KEINE Timer
âŒ KEIN direct JSON-Lesen
âŒ KEIN eigener Start/Stop-Status
âŒ KEIN LED-Handling
âŒ KEIN eigener Buffer
âŒ KEINE directen Calls zu BUFFER.get()
âŒ KEINE eigene Clock.schedule_interval

GlobalTick macht ALLES.


---

9ï¸âƒ£ Mini-Beispiel: Trend-Screen

Trendscreen zeigt Temperature trends Ã¼ber 3 Tage

Du musst nur:

deinen Graph in body einbauen

in update_from_global() neue Werte reinschreiben

in reset_from_global() buffer lÃ¶schen


Kein Timer, keine komplizierten Sachen.


---

ğŸ”Ÿ Mini-Beispiel: Log-Screen

Zeigt BLE Logs

update_from_global:

self.log.append(f"{time} RSSI {d['rssi']}")

reset_from_global:

self.log.clear()

Fertig.


---

ğŸ¯ FERTIG â€“ Der komplette Total-Guide

Mit diesem Blueprint kannst du:

beliebige Feature-Screens bauen

beliebige UI-Views erzeugen

alles perfekt synchronisieren

NIE mehr Timer-Chaos erzeugen

NIE mehr LED-Drift erzeugen

NIE mehr Header-Desync erzeugen

NIE mehr Start/Stop Chaos erzeugen


Dies ist die ultimate architecture in Kivy.


---

Wenn du willst mache ich jetzt:

ğŸ”¸ â€ready-to-copyâ€œ fertigen Screen:

TrendScreen, LogScreen, SettingsScreen, GraphCompareScreen
oder

ğŸ”¸ Ein PDF â€New Screen Handbook 1.0â€œ

Sag einfach:

â€mach TrendScreenâ€œ oder â€PDF bitteâ€œ.