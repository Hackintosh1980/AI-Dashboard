Perfekt â€” wir gehen jetzt GSM â†’ Dashboard in absolut klaren, druckfertigen Modulen.
Beide gehÃ¶ren zusammen wie MotorsteuergerÃ¤t und Cockpit.


---

ğŸ“˜ Modul: global_state_manager.py (GSM)

Die Schaltzentrale des gesamten Dashboards.

Der GSM ist der Taktgeber, der Manager, der Router.
Alle DatenflÃ¼sse laufen hier durch:

Decoder â†’ decoded.json â†’ DataBuffer â†’ GSM â†’ Dashboard
                   â†‘
              Watchdog

Er hÃ¤lt das Dashboard stabil, egal was im Backend passiert.


---

ğŸ§© 1. Hauptaufgaben des GSM

Der GlobalStateManager Ã¼bernimmt:

âœ” periodisches UI-Update (â€Tickâ€œ)

âœ” Device-Steuerung (Device Picker)

âœ” LED-Status (alive/stale/offline)

âœ” Datenvalidierung

âœ” Reset-Logik

âœ” Start/Stop des gesamten Systems (via Core)

Er ist die einzige Instanz, die das Dashboard befÃ¼llt.


---

ğŸ— 2. Interne Struktur

Du hast drei UI-KanÃ¤le:

DashboardScreen (Hauptansicht)

SetupScreen

DevicePickerScreen


Alle rufen dieselbe Instanz:

GLOBAL_STATE = GlobalStateManager()

Der GSM verknÃ¼pft alle Screens miteinander und versorgt die UI mit Daten.


---

ğŸ”„ 3. Tick-System

Der GSM setzt einen UI-Timer:

alle ui_refresh_interval Sekunden

ruft BUFFER.soft_reload()

verarbeitet die neuen Daten

ruft Dashboard.update_from_global(d)


Damit ist das Dashboard komplett event-driven durch den GSM.
Der Decoder ruft das Dashboard niemals direkt an â†’ robuste Architektur.


---

ğŸ§¬ 4. Alive / Stale / Offline Logik

Der GSM kombiniert:

alive_flag vom DataBuffer

Watchdog-Status (via update_bridge_state)


Daraus erzeugt er das LED-Signal:

GrÃ¼n â†’ alive

Orange â†’ stale

Blau â†’ offline

Grau â†’ keine Daten


Diese LED ist zu 100 % GSM-driven.


---

ğŸ“¦ 5. Beispiel eines UI-Datenpakets an Dashboard

Dashboard bekommt immer ein einziges dict:

{
    "device_id": mac,
    "alive": True/False,
    "status": "OK" / "STALE" / "OFFLINE",
    "last_seen": Sekunden,
    "external": {"present": bool},
    "temperature": float,
    "humidity": float,
    "vpd": float,
    "rssi": int
}

Alles zentralisiert.
Dashboard muss nichts wissen Ã¼ber Watchdog, Decoder oder BLE.


---

ğŸ§¯ 6. Reset-Funktion

Der Reset macht:

LED zurÃ¼cksetzen

Header zurÃ¼cksetzen

Tiles zurÃ¼cksetzen (Dashboard ruft reset_from_global())


Keine Backend-Ã„nderung.
Reiner UI-Reset.


---

ğŸ›  7. Start/Stop Pipeline

Wenn Dashboard â€Startâ€œ klickt:

GLOBAL_STATE.start()
    â†’ core.start()
    â†’ Watchdog starten
    â†’ Decoder starten
    â†’ Bridge starten (Android)

Bei Stop:

GLOBAL_STATE.stop()
    â†’ core.stop()
    â†’ Threads sauber runterfahren

Dashboard ruft nie direkt core an â†’ nur GSM.


---

ğŸŸ© 8. Device Picker Integration

Wenn mehrere GerÃ¤te existieren:

GSM hÃ¤lt current_device_id

Dashboard zeigt es oben

Der Picker meldet dem GSM: neues GerÃ¤t

GSM setzt das um:

neues device_id

neue Werte aus BUFFER lesen

Dashboard sofort aktualisieren




---


---

ğŸ“˜ Modul: dashboard.py â€“ Die Cockpit-OberflÃ¤che

Das Dashboard ist rein visuell.
Keine Logik.
Kein BLE.
Kein Decoder.
Kein Watchdog.

Es ist ein Render-Receiver vom GSM.


---

ğŸ§© 1. Aufbau

DashboardScreen besteht aus:

âœ” HeaderBar

Uhrzeit

RSSI

LED

Device Name

Buttons Setup / Debug / Picker


âœ” DashboardMainPanel

6 Haupt-Tiles

Temperatur innen

Luftfeuchte innen

VPD innen

Temperatur auÃŸen

Luftfeuchte auÃŸen

VPD auÃŸen



âœ” ControlButtons

Start

Stop

Reset



---

ğŸ”Œ 2. Datenfluss: update_from_global()

Das Dashboard bekommt alle UI-Daten Ã¼ber eine einzige Funktion:

def update_from_global(self, d)

Beispiel:

d["temperature_in"]
d["humidity_in"]
d["vpd_in"]

oder das aktuelle Device:

d["device_id"]

Das Dashboard rendert nur.


---

ğŸŒ¡ 3. Fullscreen-Modus

Wenn ein Tile geklickt wird:

open_fullscreen(tile_id)

Dashboard Ã¼bergibt an ScreenManager â†’ FullscreenScreen.

Der GSM bleibt Taktgeber.


---

ğŸ” 4. Reset-Funktion

def reset_from_global(self):
    tile_temp_in.reset()
    tile_hum_in.reset()
    tile_vpd_in.reset()
    ...

Nur optische Werte zurÃ¼cksetzen, niemals funktional.


---

ğŸš¦ 5. Led, RSSI, External GerÃ¤teanzeige

Kommt alles aus GSM, nie aus Dashboard.

Dashboard zeigt:

green â†’ OK
orange â†’ STALE
blue â†’ OFFLINE


---

ğŸ¬ 6. Start/Stop/Reset Buttons

Dashboard gibt nur weiter:

GLOBAL_STATE.start()
GLOBAL_STATE.stop()
GLOBAL_STATE.reset()

Es startet nie selbst die Bridge oder den Decoder.


---

ğŸ§± 7. StabilitÃ¤tsprinzip

Dashboard ist so gebaut, dass:

kein Crash mÃ¶glich ist, selbst wenn decoded.json Schrott ist

kein Crash bei stale/offline

kein Crash bei leerer Datei

kein Crash bei fehlenden Feldern


Warum?

Weil DataBuffer + GSM alles abfangen.


---

ğŸ§  Gesamtfluss (Endgegner-Diagramm)

Android Bridge â†’ BLE â†’ dump.json
                          â†“
                    Watchdog
                          â†“
                     Decoder
                          â†“
                   decoded.json
                          â†“
                    DataBuffer
                          â†“
                   GlobalState
                          â†“
                   Dashboard UI

Jedes Element ist getrennt.
Du hast eine extrem robuste, modulare Architektur gebaut.


---

Wenn du willst, machen wir als NÃ¤chstes:
âœ” kleine Ãœbersicht als Schaubild
âœ” eine druckfertige Dokumentation fÃ¼r deine Ordner
âœ” oder komplette technische FuÃŸnoten / API-Referenz

Sag einfach â€Weiterâ€œ.