Alles klar â€” jetzt bekommst du die vollstÃ¤ndige, druckfertige Dokumentation fÃ¼r das Settings-Modul, exakt in deiner Session-40-Architektur, ohne Abweichungen, ohne eigene Erfindungen.
Glasklar, technisch, stabil.


---

ğŸ“˜ SETTINGS â€“ Konfigurationsmodul der App

Settings gehÃ¶rt zu den kritischsten Modulen, weil es direkt Einfluss auf Core-Systeme hat (Refresh-Intervalle, Stale-Timeout, Einheiten, Offsets).
Es ist der einzige Ort, an dem die App config.json verÃ¤ndern darf.


---

ğŸ§± 1. Zweck des Settings-Moduls

Settings erfÃ¼llt vier Hauptaufgaben:

âœ” 1. Konfigurationswerte aus config.json anzeigen

Beim Ã–ffnen werden die aktuellen Werte aus:

data/config.json

in die UI-Elemente geladen (Slider, Textfelder, Dropdowns).

âœ” 2. Werte Ã¤ndern

Der Nutzer kann folgende Felder anpassen:

refresh_interval

ui_refresh_interval

stale_timeout

temperature_unit (C/F)

temperature_offset

humidity_offset

leaf_offset


âœ” 3. Ã„nderungen sicher speichern

Settings ruft ausschlieÃŸlich:

config.save(cfg)
config.reload()

auf.

âœ” 4. Laufzeitwerte aktualisieren

Damit Ã„nderungen sofort wirken, setzt Settings z. B.:

Watchdog timeout neu

UI-Refresh verwendet neuen Wert beim nÃ¤chsten Zyklus

Decoder nutzt neues refresh_interval beim nÃ¤chsten Start



---

ğŸ§± 2. Aufbau des Settings-Screens

SettingsScreen besteht aus:

1. HeaderBar


2. SettingsMainPanel (Eingabefelder)


3. Save / Cancel Buttons


4. RÃ¼cksprunglogik zum Dashboard




---

ğŸ“¦ 3. SettingsMainPanel â€“ EingabeoberflÃ¤che

Das Panel enthÃ¤lt die echten UI-Widgets:

TextInput/Slider fÃ¼r Zeiten

Dropdown fÃ¼r temperature_unit

TextInputs fÃ¼r Offsets


Diese Felder werden als values: dict zurÃ¼ckgegeben, sobald der Nutzer auf SAVE drÃ¼ckt.


---

ğŸ”§ 4. Save-Logik â€“ Der kritische Pfad

Der Save-Handler:

def _save(self, values: dict):

fÃ¼hrt exakt folgende Schritte aus:


---

Schritt 1 â€“ Config in den Speicher holen

cfg = config._init()

Dies lÃ¤dt immer die aktuelle config.json oder erstellt defaults.


---

Schritt 2 â€“ Werte Ã¼berschreiben

cfg["refresh_interval"] = float(values["refresh_interval"])
cfg["ui_refresh_interval"] = float(values["ui_refresh_interval"])
cfg["stale_timeout"] = float(values["stale_timeout"])

cfg["temperature_offset"] = float(values["temperature_offset"])
cfg["humidity_offset"] = float(values["humidity_offset"])
cfg["leaf_offset"] = float(values["leaf_offset"])

cfg["temperature_unit"] = values["temperature_unit"]

Wichtig:
Settings verÃ¤ndert NICHT:

devices

profiles

device_profiles

uuid/macs

irgendetwas Ã¼ber Sensoren



---

Schritt 3 â€“ Atomar speichern

config.save(cfg)
config.reload()

save() schreibt config.json .tmp â†’ atomar

reload() holt die Werte frisch zurÃ¼ck


Warum wichtig?
Damit Decoder, Watchdog, Core und UI konsistent werden.


---

ğŸ”¥ 5. Live-Update: Watchdog Timeout

Das war frÃ¼her ein problematischer Punkt.
Jetzt ist es sauber:

Settings erkennt, ob eine Watchdog-Instanz existiert:

if hasattr(decoder, "watchdog") and decoder.watchdog:

Wenn ja:

decoder.watchdog.timeout = float(cfg["stale_timeout"])

Damit ist der Stale-Mechanismus sofort aktiv, ohne App-Neustart.

Das ist extrem wichtig fÃ¼r:

Live-Tests

Multi-Device

Zombie-Detection

Debugging

Batterietest

Langzeit-Messungen


ğŸ’¡ Dieser Schritt ist Teil der Session-40-â€Golden Buildâ€œ-Regel:
runtime-update safe, keine Core-Eingriffe nÃ¶tig.


---

â†© 6. Cancel-Logik

def _cancel(self, *_):
    self.manager.current = "dashboard"

Cancel verwirft alles in der UI, weil nichts gespeichert wurde.


---

ğŸ§© 7. Settings und die komplette Pipeline

Settings beeinflusst die folgenden Systeme:

Setting	Effekt auf

refresh_interval	Decoder-Thread-Intervall
ui_refresh_interval	Dashboard-Refresh
stale_timeout	Watchdog-Time-Out & Stale-Detektion
offsets	Calculator â†’ Decoder â†’ Dashboard
temp_unit	Ausgabe im Dashboard (Â°C/Â°F)



---

ğŸ’¡ 8. Warum Settings so sicher ist

Settings ist absolut stabil, weil:

read â†’ modify â†’ atomic write

niemals andere Module berÃ¼hrt

niemals neue Keys erzeugt

keine Migration

keine Side-Effects

Decoder/Watchdog/Buffer arbeiten ab Sekunde 2 mit den neuen Werten


Settings ist kein Risiko-Modul mehr.
Es ist transparent, kontrolliert und simpel â€” genauso wie es sein muss.


---

ğŸ¯ 9. Kurzzusammenfassung zum Einkleben

Settings-Modul

Einziger Schreibzugang zu config.json

Macht Runtime-Updates an Watchdog mÃ¶glich

UI-Refresh passt sich ohne Neustart an

Absolut keine Eingriffe in Device-Konfiguration

Normalisiert Unit/Offset-Einstellungen fÃ¼r den Decoder

Arbeitet 100 % innerhalb Session-40-Regeln

Kein eigenes I/O auÃŸer config.json



---

Wenn du willst, mache ich jetzt direkt weiter mit:

âœ” Setup-Screen

âœ” Device Picker

âœ” Fullscreen Charts

âœ” Debug-Screen

âœ” Alle UI-Common-Module (Header, Buttons, TileBases)

Sag einfach: Weiter mit XYZ.