Genau da sitzt die Magie â€“ lass uns das einmal sauber aufdrÃ¶seln, wie Tiles, Fullscreen und GSM zusammenhÃ¤ngen, und warum â€ž1 Sensorwert = 1 Tileâ€œ so brutal flexibel ist.

Ich fasse das in drei Ebenen:

1. Datenseite (Frame / GSM)


2. Tiles im Dashboard


3. Fullscreen umschalten




---

1. Datenseite â€“ was GSM pro Tick liefert

Der GlobalStateManager bekommt pro Tick genau EIN Frame fÃ¼r das aktuell aktive GerÃ¤t:

{
    "device_id": "AA:BB:CC:00:30:02",
    "internal": {
        "temperature": {"value": 24.3, "unit": "Â°C"},
        "humidity":    {"value": 55.0, "unit": "%"},
    },
    "external": {
        "present": True,
        "temperature": {"value": 21.0, "unit": "Â°C"},
        "humidity":    {"value": 60.0, "unit": "%"},
    },
    "vpd_internal": {"value": 1.2, "unit": "kPa"},
    "vpd_external": {"value": 0.9, "unit": "kPa"},
    "alive": True,
    "status": "active",
    ...
    "_active_keys": ["temp_in", "hum_in", "vpd_in", "temp_ex", "hum_ex", "vpd_ex"]
}

Wichtig dabei:

GSM baut _active_keys:

def extract_active_keys(self, d):
    active = []
    if d["internal"]["temperature"]["value"] is not None:
        active.append("temp_in")
    if d["internal"]["humidity"]["value"] is not None:
        active.append("hum_in")
    if d["vpd_internal"]["value"] is not None:
        active.append("vpd_in")

    if d["external"]["present"]:
        if d["external"]["temperature"]["value"] is not None:
            active.append("temp_ex")
        if d["external"]["humidity"]["value"] is not None:
            active.append("hum_ex")
        if d["vpd_external"]["value"] is not None:
            active.append("vpd_ex")

    return active

Das ist schon der erste Flex-Punkt:

GerÃ¤t ohne AuÃŸensensor â†’ keine temp_ex, hum_ex, vpd_ex in _active_keys.

GerÃ¤t ohne VPD â†’ keine vpd-Keys.

KÃ¼nftige Sensoren (z.B. Leaf-Temp, Battery, Bodenfeuchte) â†’ einfach neue Keys definieren (z.B. "leaf", "soil") und Tiles, die diese Keys verstehen.



Der GSM ist also die einzige Instanz, die entscheidet:

Welche Sensorwerte existieren?

Welche davon sind â€žaktivâ€œ?


Und nur das geht weiter an Dashboard & Fullscreen.


---

2. Dashboard-Tiles â€“ 1 Sensorwert = 1 Tile

Im Dashboard hast du sechs Haupt-Tiles (Session40):

tile_temp_in

tile_hum_in

tile_vpd_in

tile_temp_ex

tile_hum_ex

tile_vpd_ex


Die Mechanik:

def update_from_global(self, d):
    self.header.set_device_label(mac)
    ...
    self.content.update_from_data(d)

DashboardMainPanel.update_from_data(d) macht in etwa:

FÃ¼r jeden bekannten Key (temp_in, hum_in, â€¦):

Hole Wert aus d

Update genau ein Tile dafÃ¼r

Falls Key nicht in _active_keys â†’ Tile im â€žghost/offâ€œ-Zustand (z.B. grau, keine Kurve)



ðŸ‘‰ Ergebnis:
Jeder Sensorwert existiert maximal ein Mal im UI.
Kein Tile zeigt zwei verschiedene Sensoren, keine Doppelbelegung.

Das ist dein â€žUltimate IV flexibelâ€œ-Prinzip:

Willst du eine neue Sensorart anzeigen â†’ du definierst:

einen neuen Key (z.B. "battery")

ein neues Tile-Objekt im Panel

eine simple Mapping-Regel: Key âžœ Tile


Alles andere (GSM, Buffer, Core, Decoder) bleibt identisch.


Dadurch:

Kein Spaghetti: kein Tile muss wissen, welche Kombination von Sensoren gerade â€žMode 1â€œ oder â€žMode 2â€œ ist.

Immer 1:1-Zuordnung: Key â†” Tile â†” Fullscreen-Graph.



---

3. Fullscreen â€“ Umschalten welches Sensor-Signal groÃŸ gezeigt wird

Jetzt der interessante Teil: Tile â†’ Fullscreen.

Im Dashboard:

def open_fullscreen(self, tile_id):
    fs = self.manager.get_screen("fullscreen")
    fs.activate_tile(tile_id)
    self.manager.current = "fullscreen"

tile_id ist z.B. "temp_in", "hum_in", "vpd_ex"

Diese ID ist gleich dem Key, den GSM in _active_keys benutzt â†’ kein Sondermapping, kein extra Modus.


Im Fullscreen-Screen passiert dann:

activate_tile(tile_id) speichert:

self.current_key = tile_id


Beim nÃ¤chsten Tick vom GSM:

def update_from_global(self, d):
    key = self.current_key          # z.B. "temp_in"
    value = ... aus d anhand key ...  # z.B. d["internal"]["temperature"]["value"]
    self.chart.append_point(timestamp, value)
    self.header.set_device_label(d["device_id"])


Mechanik dahinter:

1. Dashboard-Tile wird angeklickt
â†’ tile_id geht 1:1 als Key in den Fullscreen.


2. Fullscreen ist NICHT eigene Logik, sondern:

HÃ¤ngt am gleichen GSM-Tick

Liest das gleiche Frame d

Nutzt nur einen einzigen Key (self.current_key)



3. Ein GerÃ¤t mit weniger Sensoren:

_active_keys enthÃ¤lt z.B. nur ["temp_in", "hum_in"]

Wenn du versuchst "temp_ex" fullscreen zu Ã¶ffnen â†’ Graph kriegt stÃ¤ndig None â†’ Kurve bleibt leer oder UI blendet es aus.




Dadurch ist Fullscreen:

Ultra-stabil:
Kein eigener Timer, keine eigene Datei, kein eigener Decoder â€“ nur eine andere â€žAnsichtâ€œ auf denselben Daten.

Ultra-flexibel:
Neue Sensoren â†’ neuer Key â†’ neuer Tile â†’ Fullscreen bekommt den Key automatisch mit.



---

4. Warum das â€ž1 Wert = 1 Tile = 1 Fullscreenâ€œ so mÃ¤chtig ist

Vorteile:

1. Keine Mehrfachlogik

Du musst nie rÃ¤tseln: â€žNa wo rechnet jetzt die VPD-Kurve, Dashboard oder Fullscreen?â€œ

Alles kommt aus dem Frame (decoded.json â†’ BUFFER â†’ GSM â†’ d).



2. Beliebig erweiterbar

SpÃ¤ter: Battery-Tile, RSSI-Tile, Leaf-Temp-Tile, Bodenfeuchte-Tile, Health-Tile â€¦

Du hÃ¤ngst nur:

einen Key in _active_keys

ein passendes Tile

einen Fullscreen-Graph, der exakt denselben Key nutzt




3. Volle Multi-Device-UnterstÃ¼tzung

GSM wÃ¤hlt Device-Index (active_index)

Alle Tiles + Fullscreen zeigen immer nur das eine aktive GerÃ¤t.

Wechsel im Device-Picker â†’ GSM wechselt Index â†’ alles (Header, Tiles, Fullscreen) springt synchron um.



4. Keine Doppelbelegung

Ein Wert = ein UI-Element

Kein â€žTemp_in in zwei Kachelnâ€œ, kein â€žextern im inneren Tileâ€œ. Alles sauber.





---

5. Zusammengefasst in einem Mini-Flow

1. Decoder â†’ decoded.json
2. DataBuffer lÃ¤dt decoded.json in BUFFER.data
3. GSM holt BUFFER.get() â†’ wÃ¤hlt aktives Device â†’ baut _active_keys
4. GSM tickt:

dashboard.update_from_global(d)

fullscreen.update_from_global(d)

setup.update_from_global(d) (fÃ¼r Header/LED)


5. Dashboard:

Tiles lesen immer â€žihrenâ€œ Key: temp_in, hum_ex, â€¦

Layout & Sichtbarkeit abhÃ¤ngig von _active_keys.


6. Fullscreen:

Bekommt tile_id = Key

Zeichnet nur diese Zeitreihe groÃŸ.



---

Wenn du mÃ¶chtest, kann ich dir als nÃ¤chsten Schritt noch so eine Key-Tabelle machen:

temp_in â†’ d["internal"]["temperature"]["value"]

hum_in â†’ d["internal"]["humidity"]["value"]

vpd_in â†’ d["vpd_internal"]["value"]

temp_ex â†’ d["external"]["temperature"]["value"]

hum_ex â†’ d["external"]["humidity"]["value"]

vpd_ex â†’ d["vpd_external"]["value"]


Dann kannst du das direkt mit ins Doku-Heft kleben.