Alles klar â€” jetzt kommt die Dashboard-Dokumentation, komplett sauber, modulweise, so dass du es 1:1 in dein Handbuch Ã¼bernehmen kannst.
Dies ist einer der wichtigsten Teile deines gesamten Projekts, weil hier alle Core-Systeme (Decoder, Watchdog, Bridge, Config, Buffer) sichtbar werden.


---

ğŸ“˜ DASHBOARD â€“ Das HerzstÃ¼ck der App

Das Dashboard ist die Hauptanzeige deiner Sensorwelt.
Hier verschmelzen:

decoded.json

watchdog-Status

Device-Profile

Temperature/Humidity/VPD

LED-Statusanzeige

HeaderBar (Online/Offline)

Tile Layout

GSM / Screenmanager

Live-Refresh


Alle Logik ist read-only â€“ Dashboard schreibt NIE etwas zurÃ¼ck.
Es konsumiert nur die Daten aus deinem System.


---

ğŸ§± 1. ArchitekturÃ¼berblick (Datenfluss)

ğŸ”¸ BLE â†’ RAW

(Android-Bridge schreibt ble_dump.json)

ğŸ”¸ RAW â†’ DECODER

DecoderThread erzeugt jedes Intervall eine neue:

data/decoded.json

ğŸ”¸ DECODER + WATCHDOG

FÃ¼r jedes GerÃ¤t im Config:

alive = True â†’ neue Daten

alive = False + status="STALE" â†’ Zombie

alive = False + status="OFFLINE" â†’ Tot


Diese Flags werden in decoded.json geschrieben.
Dashboard sieht nur das Resultat.

ğŸ”¸ DECODING â†’ DataBuffer

Dashboard liest Ã¼ber:

BUFFER.load()

ğŸ”¸ DataBuffer â†’ GlobalState

Hier werden Mapping + LED Logik entschieden.

ğŸ”¸ GlobalState â†’ DashboardTiles

Jedes UI-Element bekommt seine Werte & farbliche LED.


---

ğŸ“¦ 2. DataBuffer â€“ Feed fÃ¼r das Dashboard

DataBuffer ist der Mini-Server innerhalb der UI.

BUFFER = DataBuffer()

Er macht:

prÃ¼ft, ob decoded.json existiert

lÃ¤dt die Datei

validiert sie (Liste, EintrÃ¤ge, alive-Feld)

liefert die vollstÃ¤ndigen Frames an das Dashboard


Wichtig:
DataBuffer ist der einzige Ort, der direkt auf decoded.json zugreift.

Felder:

file_exists â†’ Datei da oder nicht

data_ok â†’ JSON gÃ¼ltig

alive_flag â†’ erstes Device alive? (fÃ¼r LED)

data â†’ echter Inhalt der Datei


Damit ist DataBuffer â†’ Dashboard dein stabiler UI-Pipeline.


---

ğŸ§¿ 3. GlobalState â€“ Der Logik-Layer zwischen Buffer & UI

GlobalState (in dashboard) Ã¼bernimmt die Aufgabe:

âœ” Alive/OK/Stale/Offline klassifizieren

FÃ¼r jedes GerÃ¤t wird aus den decoded.json-Feldern:

alive

status ("active" / "offline")

packet_counter

last_seen

rssi


der echte UI-Status berechnet.

âœ” Farbcodes definieren

Hier entsteht deine LED-Logik:

Zustand	Bedeutung	LED

OK (alive=True)	Daten flieÃŸen	ğŸŸ¢ GrÃ¼n
STALE	RAW unverÃ¤ndert, > timeout	ğŸŸ¡ Gelb
OFFLINE	dump fehlt / GerÃ¤t fehlt	ğŸ”´ Rot
NO FILE	decoded.json fehlt	ğŸ”´ Rot blinkend (optional)


GlobalState ist also die Ãœbersetzungsmaschine zwischen systeminternen Flags und UI-Farben.

âœ” Mapping der Sensorwerte

Alle Temperatur-, Feuchte- und VPD-Werte werden hier in stabile Werte umgewandelt:

None â†’ "â€”"

floats â†’ formatiert

Einheiten â†’ aus config Ã¼bernommen


âœ” Liefert fertige Strukturen an die Tiles

Ein Tile bekommt:

{
  "Ti": 21.4,
  "Hi": 55.1,
  "Te": None,
  "He": None,
  "vpd_i": 0.98,
  "alive": True,
  "status_color": (0,1,0,1)  # grÃ¼n
}


---

ğŸŸ© 4. LED-STATUS â€“ die entscheidende Logik

Die LED ist der Gesundheitsindikator fÃ¼r jedes GerÃ¤t.
Sie basiert ausschlieÃŸlich auf den Feldern aus decoded.json:

Entscheidungsreihenfolge:

if data_missing:
    LED = RED

elif alive == True:
    LED = GREEN

elif status == "STALE":
    LED = YELLOW

else:
    LED = RED

Merke: dead_decode = dead_UI.
Wenn decoded.json nicht existiert â†’ LED ROT.

Das schÃ¼tzt dich vor "Geisterdaten".


---

ğŸ§± 5. DashboardScreen â€“ Aufbau

Der Screen besteht aus:

âœ” HeaderBar

ZurÃ¼ck zu anderen Screens

Zeigt Online/Offline/STALE

Bekommt Status aus GlobalState


âœ” MainPanel

GridLayout der Sensor Tiles.
Alle Werte sind read-only.

âœ” Periodic Refresh

Der gesamte Screen wird mit:

config.get_ui_refresh_interval()

alle X Sekunden aktualisiert (standardmÃ¤ÃŸig 1 Sekunde).

Die Schritte:

1. BUFFER.soft_reload()


2. GlobalState.update_from_buffer()


3. Tiles refresh()



Wichtig:
Dashboard lÃ¤uft komplett unabhÃ¤ngig von Core, Watchdog, Decoder.
Es sieht nur decoded.json.


---

ğŸ¨ 6. Tiles â€“ UI-Bausteine pro GerÃ¤t

Jedes GerÃ¤t hat ein eigenes Tile.

Darstellung:

Name

Profil

Temperatur innen

Temperatur auÃŸen

Luftfeuchte

VPD

SignalstÃ¤rke

LED-Statusanzeige


Jede Farbe kommt aus GlobalState â†’ niemals hart verdrahtet.

Wenn ein GerÃ¤t tot ist:

Werte = "â€”"

LED = Rot

Name = "Offline"

Border rot

Keine WerteÃ¤nderung mehr


Das Tile selbst enthÃ¤lt keinerlei Logik â€“ reine Anzeige.


---

ğŸ”Œ 7. GSM â€“ der Verbindungsmanager

Dashboard nutzt GSM (Global Screen Manager) fÃ¼r Navigation:

Setup

Debug

Device Picker

Fullscreen Charts


Dashboard ist der Default-Screen nach Start.

Wenn der Decoder startet und decoded.json erzeugt, springt das Dashboard automatisch in einen funktionsfÃ¤higen Zustand.


---

ğŸ”„ 8. Zusammenfassung des Dashboard-Flows

1ï¸âƒ£ decoded.json â†’ DataBuffer

2ï¸âƒ£ DataBuffer â†’ GlobalState

3ï¸âƒ£ GlobalState â†’ Tiles

4ï¸âƒ£ Tiles â†’ LED-Anzeige

5ï¸âƒ£ HeaderBar erhÃ¤lt Online/Offline

6ï¸âƒ£ Refresh alle 1 Sekunde

Keine seitlichen Effekte.
Dashboard ist komplett passiv, sicher, stabil.


---

ğŸ’¬ Willst du jetzt Fullscreen / Chart-Dokumentation oder die Debug-Module?