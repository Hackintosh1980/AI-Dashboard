Alles klar â€” jetzt dokumentieren wir die Common-Module, also dein berÃ¼hmtes â€Dreigestirnâ€œ:

HeaderBar (oben)

ControlButtons (unten)

DevicePicker-Button + Back-Button-System


Das sind zentrale UI-Bausteine, die in jeder Ansicht gleich funktionieren.
Absolut wichtig fÃ¼r StabilitÃ¤t, UX und Wiedererkennung.


---

ğŸ“˜ Modul: ui/common/header_online.py â€“ Die HeaderBar

ğŸ¯ Aufgabe

Der Header ist das Navigations- und Statuszentrum des ganzen Dashboards.

Er hat vier Kernbereiche:

1. Links: ZurÃ¼ck-Button (konteextabhÃ¤ngig gesteuert)


2. Mitte: Device-Label, Uhrzeit


3. Rechts:

Debug

Setup

Device-Picker



4. Rechts auÃŸen: LED-Status (OK / STALE / OFFLINE)



Der Header ist rein UI â€” alles, was er anzeigt, kommt von GSM.


---

ğŸ§¬ Funktionen (Ã¶ffentliche API)

âœ” update_back_button(mode)

Bestimmt, ob der Back-Button sichtbar ist und wohin er fÃ¼hrt:

mode="dashboard" â†’ kein Back

mode="settings" â†’ zurÃ¼ck zum Dashboard

mode="setup" â†’ ebenfalls zurÃ¼ck

mode="fullscreen" â†’ zurÃ¼ck auf Dashboard


Der Header entscheidet nie selbst, wohin â€” das gibt der Screen vor.


---

âœ” set_device_label(text)

Zeigt den aktuellen Sensor an:

Beispiele:

"AA:BB:CC:00:30:02"

"NO-DEVICE"


Kommt von GSM (device_id).


---

âœ” set_clock(timestamp)

Wird einmal pro UI-Tick gesetzt.


---

âœ” set_rssi(value)

Zeigt die gemessene SignalstÃ¤rke aus decoded.json an.

Falls kein Wert: "--"


---

âœ” set_led(state)

Nimmt einen der drei Strings:

"OK"

"STALE"

"OFFLINE"


Der Header kÃ¼mmert sich NUR um Farbe/Style.


---

ğŸ§© Navigation-Buttons

Der Header ruft immer nur Callbacks:

goto_setup()

goto_debug()

goto_device_picker()


Dadurch bleibt er zu 100 % dumm und safe.

Er kennt weder GSM noch Decoder noch Config.


---

ğŸ“˜ Modul: ui/common/control_buttons.py â€“ Die 3 Steuerbuttons unten

ğŸ¯ Aufgabe

Das untere Control-Panel ist die Hauptsteuerung des Systems.

Besteht aus drei Buttons:

1. Start


2. Stop


3. Reset



Alle Buttons rufen NUR die Callbacks des DashboardScreens auf:

on_start

on_stop

on_reset


Der Screen reicht es weiter:

GLOBAL_STATE.start()

GLOBAL_STATE.stop()

GLOBAL_STATE.reset()


ğŸ’¡ Wichtig:
Die Buttons haben selbst keinen Status, sie lesen keine Daten und steuern nichts.
Reine Event-Trigger fÃ¼r GSM.


---

ğŸ“˜ Modul: DevicePicker-Button / Inline-Auswahl

(Der â€â‡…â€œ Button im Header)

Dieser Button Ã¶ffnet:

den DevicePicker-Screen

dort kann man den aktiven Sensor wÃ¤hlen

GSM Ã¼bernimmt die Auswahl


Der Header selbst macht NUR:

goto_device_picker() â†’ ScreenManager.current="device_picker"

Er entscheidet NICHT, welches Device aktiv ist.


---

ğŸ§  Warum â€Dreigestirnâ€œ?

Weil diese drei Common-Module die stabile, unverÃ¤nderbare UI-Welt sind:

Header = Kopf

Dashboard Main Panel = KÃ¶rper

Control Buttons = Beine


Sie bleiben identisch Ã¼ber alle Screens hinweg.

Dadurch ist die UX:

sauber

konsistent

fehlersicher

intuitiv


Und du hast sie perfekt gekapselt:
Keine globale Logik, keine Core-Ã„nderungen, nur UI.


---

ğŸ“¦ Was dokumentieren wir als NÃ¤chstes?

Du kannst wÃ¤hlen:

1. Tiles (Temp/Hum/VPD) + deren Fullscreen-Modus


2. DevicePicker-Modul


3. DashboardMainPanel Aufbau


4. SetupScreen + SetupMainPanel


5. SettingsScreen + SettingsMainPanel


6. UI-Scaling / dp_scaled / sp_scaled



Sag einfach: â€Tilesâ€œ, â€Pickerâ€œ, â€Setupâ€œ, â€Settingsâ€œ oder â€Scalingâ€œ.