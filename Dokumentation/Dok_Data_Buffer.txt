Alles klar â€” glasklare Doku, exakt in der Reihenfolge:

1. data_buffer.py


2. global_state_manager.py (GSM)


3. dashboard.py (DashboardScreen)



Wir starten jetzt mit deinem DataBuffer, exakt so wie du ihn gebaut hast.


---

ğŸ“˜ Modul: data_buffer.py â€“ Das Datenfenster des Dashboards

DataBuffer ist das einzige Modul, aus dem das Dashboard seine Daten bezieht.
Es fungiert als UI-seitiger Cache & Reader fÃ¼r:

data/decoded.json

Der Decoder schreibt â†’ DataBuffer liest.
Keine Logik, keine Berechnung, kein BLE.
Reine, sichere UI-Zufuhr.


---

ğŸ§© 1. Rolle des DataBuffer

Der DataBuffer erledigt drei Dinge:

âœ” liest regelmÃ¤ÃŸig decoded.json

âœ” prÃ¼ft, ob die Datei existiert

âœ” extrahiert drei Statusfelder fÃ¼r das Dashboard:

Datei vorhanden (file_exists)

Daten gÃ¼ltig (data_ok)

GerÃ¤t alive (alive_flag)


Diese drei Flags steuern:

LED

Anzeigen

Steuersperren

Dashboard-Update logic



---

ğŸš€ 2. Klassenstruktur

class DataBuffer:
    def __init__(self):
        self.path = "data/decoded.json"
        self.data = None

        self.file_exists = False
        self.data_ok = False
        self.alive_flag = False

Das bedeutet:

self.path â†’ feste Pipeline

self.data â†’ aktueller Inhalt (oder None)

self.file_exists â†’ Dashboard weiÃŸ sofort: Data vorhanden oder nicht

self.data_ok â†’ Struktur stimmt? Liste? Nicht leer?

self.alive_flag â†’ Status direkt aus Decoder Ã¼bernommen



---

ğŸ“¥ 3. load() â€“ das HerzstÃ¼ck

load() ist die Hauptlesefunktion.

Sie macht Schritte:

1ï¸âƒ£ PrÃ¼fen: existiert die Datei?

self.file_exists = os.path.exists(self.path)

Wenn nein:

Dashboard bekommt:


file_exists = False
data_ok = False
alive_flag = False
data = None

2ï¸âƒ£ Versuch Datei zu laden

with open(...) as f:
    self.data = json.load(f)

Fehler â†’ data bleibt None.

3ï¸âƒ£ Validierung der Datenstruktur:

Muss list sein

Muss len > 0 sein


Wenn das stimmt:

self.data_ok = True
self.alive_flag = bool(first_entry["alive"])

Wenn nicht:

data_ok = False
alive_flag = False


---

ğŸ“¤ 4. get() â€“ Liefert letzter Stand

Getter ohne Reload:

def get(self):
    return self.data

Das Dashboard ruft es beim UI-Refresh ab.


---

ğŸ”„ 5. soft_reload() â€“ sanfte Aktualisierung

def soft_reload(self):
    return self.load()

Wird vom GSM zyklisch benutzt.


---

ğŸŒ 6. Globales Singleton

BUFFER = DataBuffer()

Damit kann die gesamte UI Ã¼berall auf dieselbe Instanz zugreifen.


---

ğŸ§  Warum ist DataBuffer so wichtig?

Weil er ein absolut risikofreies UI-Fenster baut:

Kein Thread

Keine Watchdog- oder BLE-Logik

Kein Zugriff auf Bridge

Kein Zutun an decoded.json

Pure Readonly-Sicherheit


Wenn der Decoder Mist baut â†’ Dashboard crasht nicht
Wenn Watchdog stale ist â†’ Dashboard zeigt sauber Fehler
Wenn Datei verschwindet â†’ Dashboard zeigt OFFLINE

Der DataBuffer isoliert das Dashboard komplett vom Backend.
Das ist extrem professionell gelÃ¶st.


---

NÃ¤chster Schritt sofort bereit:

ğŸ‘‰ global_state_manager.py â€“ DIE SCHALTZENTRALE
Sobald du â€Weiterâ€œ sagst, beschreibe ich:

Tick-System

Alive/Offline Handling

Device-Wechsel

Buffer â†’ Dashboard Flow

Watchdog Integration

Start/Stop/Reset Pipeline


Sag einfach:
â€Weiter mit GSMâ€œ